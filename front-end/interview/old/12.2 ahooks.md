## Installation

To install the `ahooks` library, you can use npm or yarn:

```bash
$ npm install --save ahooks
# or
$ yarn add ahooks
# or
$ pnpm add ahooks
# or
$ bun add ahooks
```

## `useRequest`

### Key Features of useRequest

1. **Simplified Data Fetching**:
   - `useRequest` abstracts the complexities of making asynchronous requests, allowing developers to focus on application logic rather than boilerplate code.

2. **Loading and Error States**:
   - Automatically manages loading and error states, providing hooks (`loading`, `error`) that can be used to display appropriate UI elements (e.g., spinners, error messages).

3. **Polling and Refreshing**:
   - Supports polling (making repeated requests at specified intervals) and manual refreshing, making it easy to keep data up-to-date.

4. **Debouncing and Throttling**:
   - Built-in support for debouncing and throttling requests helps to optimize network usage and improve performance.

5. **Pagination and Load More**:
   - Offers utilities to handle pagination and infinite scrolling scenarios, simplifying the implementation of these common patterns.

6. **Retry Mechanism**:
   - Automatically retries failed requests with customizable retry logic, improving the reliability of data fetching.

### Basic Usage

Here's a simple example to demonstrate the basic usage of `useRequest`:

```javascript
import React from 'react';
import { useRequest } from 'ahooks';
import axios from 'axios';

const fetchUserData = () => {
  return axios.get('https://api.example.com/user');
};

const UserComponent = () => {
  const { data, error, loading } = useRequest(fetchUserData);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h1>User Data</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
};

export default UserComponent;
```

### Advanced Features

1. **Polling**:
   ```javascript
   const { data, run, cancel } = useRequest(fetchUserData, {
     pollingInterval: 5000, // poll every 5 seconds
   });

   // Call `cancel` to stop polling
   ```

2. **Debouncing**:
   ```javascript
   const { run } = useRequest(fetchUserData, {
     debounceInterval: 300, // debounce for 300ms
   });

   // Call `run` to trigger the request
   ```

3. **Pagination**:
   ```javascript
   const { data, loading, loadMore, noMore } = useRequest(
     ({ currentPage }) => fetchUserData(currentPage),
     {
       paginated: true,
       loadMore: true,
     }
   );

   // Call `loadMore` to fetch the next page of data
   ```

4. **Retry**:
   ```javascript
   const { data, error, loading } = useRequest(fetchUserData, {
     retryCount: 3, // retry up to 3 times on failure
     retryInterval: 1000, // wait 1 second between retries
   });
   ```

5. **Manual Trigger**:
   ```javascript
   const { data, run } = useRequest(fetchUserData, {
     manual: true,
   });

   // Call `run` to manually trigger the request
   ```

6. **Custom Request Instance**:
   ```javascript
   import { request } from 'umi'; // or any other request library

   const { data, error, loading } = useRequest(
     () => request('/api/user'),
     {
       requestMethod: (params) => request(params), // use a custom request method
     }
   );
   ```

### Customizing Behavior

The `useRequest` hook can be customized extensively through its options:

- `defaultParams`: Default parameters for the request function.
- `onSuccess`: Callback function to be called on successful response.
- `onError`: Callback function to be called on error.
- `onBefore`: Callback function to be called before the request is made.
- `onFinally`: Callback function to be called after the request is completed (regardless of success or error).

Example:

```javascript
const { data, run } = useRequest(fetchUserData, {
  manual: true,
  defaultParams: [initialParams],
  onSuccess: (result, params) => {
    console.log('Request succeeded with params:', params);
  },
  onError: (error, params) => {
    console.error('Request failed with params:', params);
  },
  onBefore: (params) => {
    console.log('Request started with params:', params);
  },
  onFinally: (params) => {
    console.log('Request completed with params:', params);
  },
});
```

## `useMemoizedFn`

`useMemoizedFn` is a hook provided by the ahooks library, which is a collection of high-quality and reliable React hooks. This hook is specifically designed to handle the memoization of functions in a more efficient way, ensuring that the same function reference is maintained across renders unless its dependencies change. Here's a detailed overview and comparison with `useCallback`.

#### Features of `useMemoizedFn`

1. **Persistent Function Reference**: `useMemoizedFn` ensures that the function reference remains the same across re-renders, which helps in avoiding unnecessary re-renders of child components that depend on this function.

2. **Dependency Management**: Unlike `useCallback`, `useMemoizedFn` does not require dependencies to be passed. It automatically manages dependencies and ensures that the memoized function is updated only when necessary.

3. **Simplicity**: The API is straightforward and does not require passing dependency arrays, making it less error-prone and simpler to use.

#### Usage

Here’s how you can use `useMemoizedFn`:

```javascript
import { useMemoizedFn } from 'ahooks';

function MyComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useMemoizedFn(() => {
    console.log(count);
  });

  return (
    <div>
      <p>{count}</p>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
}
```

In this example, `handleClick` maintains the same reference across renders, ensuring efficient updates.

### Comparison with `useCallback`

`useCallback` is a React hook that also memoizes functions, but there are some key differences between `useCallback` and `useMemoizedFn`.

#### `useCallback` Characteristics

1. **Dependency Array**: `useCallback` requires a dependency array to be passed. The memoized function will only change if one of the dependencies changes.
   
   ```javascript
   const memoizedCallback = useCallback(
     () => {
       doSomething(a, b);
     },
     [a, b],
   );
   ```

2. **Explicit Control**: By using a dependency array, `useCallback` gives you explicit control over when the memoized function should update.

3. **Potential for Errors**: If dependencies are not managed correctly, it can lead to bugs where the memoized function does not update when expected, or updates unnecessarily.

#### Advantages of `useMemoizedFn` over `useCallback`

1. **Ease of Use**: `useMemoizedFn` does not require a dependency array, reducing the chance of making mistakes related to dependency management.

2. **Automatic Dependency Management**: It automatically ensures that the function is updated when necessary, abstracting away the complexity.

3. **Consistent Function Reference**: It guarantees a consistent function reference across renders, which is useful in scenarios where maintaining a stable function reference is crucial, such as in event handlers or callbacks passed to deeply nested components.

#### When to Use Each Hook

- **`useCallback`**: Use when you need explicit control over when the memoized function should update based on specific dependencies. It is useful when the dependencies are few and easy to manage.

- **`useMemoizedFn`**: Use when you want a simpler and more reliable way to memoize functions without worrying about dependencies. It is particularly useful in complex components where dependency management can become cumbersome.

### `useToggle` vs. `useBoolean`

### `useToggle`

**Description:**
`useToggle` is a hook designed to manage a boolean state with an easy-to-use API for toggling the state between `true` and `false`.

**Usage:**
```javascript
import { useToggle } from 'ahooks';

const [state, { toggle, setLeft, setRight }] = useToggle();
```

**API:**
- `state`: The current boolean state.
- `toggle`: A function to switch the state between `true` and `false`.
- `setLeft`: A function to set the state to `false`.
- `setRight`: A function to set the state to `true`.

**Example:**
```javascript
const MyComponent = () => {
  const [state, { toggle, setLeft, setRight }] = useToggle();

  return (
    <div>
      <p>Current state: {state.toString()}</p>
      <button onClick={toggle}>Toggle</button>
      <button onClick={setLeft}>Set False</button>
      <button onClick={setRight}>Set True</button>
    </div>
  );
};
```

### `useBoolean`

**Description:**
`useBoolean` is another hook from `ahooks` for managing boolean state, offering similar functionality to `useToggle` but with a slightly different API.

**Usage:**
```javascript
import { useBoolean } from 'ahooks';

const [state, { setTrue, setFalse, toggle }] = useBoolean();
```

**API:**
- `state`: The current boolean state.
- `setTrue`: A function to set the state to `true`.
- `setFalse`: A function to set the state to `false`.
- `toggle`: A function to switch the state between `true` and `false`.

**Example:**
```javascript
const MyComponent = () => {
  const [state, { setTrue, setFalse, toggle }] = useBoolean();

  return (
    <div>
      <p>Current state: {state.toString()}</p>
      <button onClick={toggle}>Toggle</button>
      <button onClick={setTrue}>Set True</button>
      <button onClick={setFalse}>Set False</button>
    </div>
  );
};
```

### Comparison between `useToggle` and `useBoolean`

**Similarities:**
1. **Purpose:** Both hooks are designed to manage boolean state in React components.
2. **API Methods:** Both provide methods to toggle the state and explicitly set it to `true` or `false`.
3. **Ease of Use:** Both hooks are simple to implement and use, making state management straightforward.

**Differences:**
1. **Naming Conventions:** The primary difference lies in the naming of the methods provided by the hooks.
   - `useToggle`: `toggle`, `setLeft`, `setRight`
   - `useBoolean`: `toggle`, `setTrue`, `setFalse`
2. **Intuitiveness:** The method names in `useBoolean` (`setTrue`, `setFalse`) may be more intuitive to understand at first glance compared to `useToggle` (`setLeft`, `setRight`).
3. **Consistency:** `useBoolean` may align better with naming conventions and expectations in other React hooks or state management patterns (`setTrue`, `setFalse` vs. `setLeft`, `setRight`).

### Conclusion

Both `useToggle` and `useBoolean` from `ahooks` serve the same fundamental purpose of managing boolean state with slight differences in their API design. Choosing between them may come down to personal preference or specific project conventions. `useBoolean` provides more intuitive method names (`setTrue`, `setFalse`), while `useToggle` offers similar functionality with slightly different naming (`setLeft`, `setRight`). Both are effective tools for handling boolean state in React applications.

## `useDynamicList`

`useDynamicList` is particularly useful for managing dynamic lists, providing a set of methods to manipulate the list's state efficiently.

### Key Features
- **Dynamic List Management**: Easily add, remove, update, and manipulate list items.
- **Immutable Updates**: Ensures state updates are done immutably, preserving React's state management principles.
- **Convenient API**: Provides a set of methods to handle common list operations.

### Basic Usage
Here’s a basic example of how to use `useDynamicList`:

```jsx
import React from 'react';
import { useDynamicList } from 'ahooks';

const DynamicListComponent = () => {
  const { list, insert, remove, move, push, reset, getKey, getIndex, merge, replace, shift, pop, unshift, sortList } = useDynamicList([1, 2, 3]);

  return (
    <div>
      <button onClick={() => push(Math.random())}>Add Random</button>
      <button onClick={() => remove(0)}>Remove First</button>
      <ul>
        {list.map((item, index) => (
          <li key={getKey(index)}>{item}</li>
        ))}
      </ul>
    </div>
  );
};

export default DynamicListComponent;
```

### API Methods

- **list**: The current state of the list.
- **insert(index, item)**: Inserts an item at the specified index.
- **remove(index)**: Removes the item at the specified index.
- **move(fromIndex, toIndex)**: Moves an item from one index to another.
- **push(...items)**: Adds one or more items to the end of the list.
- **reset(newList)**: Resets the list to the new list provided.
- **getKey(index)**: Returns a unique key for the item at the specified index.
- **getIndex(key)**: Returns the index of the item with the specified key.
- **merge(index, items)**: Merges items into the list at the specified index.
- **replace(index, item)**: Replaces the item at the specified index with a new item.
- **shift()**: Removes the first item of the list.
- **pop()**: Removes the last item of the list.
- **unshift(...items)**: Adds one or more items to the beginning of the list.
- **sortList(compareFunction)**: Sorts the list with the specified compare function.

### Example Methods Usage

- **insert(index, item)**:

  ```jsx
  insert(1, 'newItem');
  ```

- **remove(index)**:

  ```jsx
  remove(0);
  ```

- **move(fromIndex, toIndex)**:

  ```jsx
  move(2, 0);
  ```

- **push(...items)**:

  ```jsx
  push('item1', 'item2');
  ```

- **reset(newList)**:

  ```jsx
  reset([4, 5, 6]);
  ```

- **getKey(index)**:

  ```jsx
  const key = getKey(2);
  ```

- **getIndex(key)**:

  ```jsx
  const index = getIndex(key);
  ```

- **merge(index, items)**:

  ```jsx
  merge(1, ['a', 'b']);
  ```

- **replace(index, item)**:

  ```jsx
  replace(2, 'replacedItem');
  ```

- **shift()**:

  ```jsx
  shift();
  ```

- **pop()**:

  ```jsx
  pop();
  ```

- **unshift(...items)**:

  ```jsx
  unshift('startItem1', 'startItem2');
  ```

- **sortList(compareFunction)**:

  ```jsx
  sortList((a, b) => a - b);
  ```

### Advanced Usage

**Maintaining Keys:**
Each item in the list has a unique key to help with React's reconciliation process.

```jsx
const { list, getKey } = useDynamicList([{ id: 1, value: 'a' }, { id: 2, value: 'b' }]);

return (
  <ul>
    {list.map((item, index) => (
      <li key={getKey(index)}>{item.value}</li>
    ))}
  </ul>
);
```

**Sorting List:**

```jsx
const { list, sortList } = useDynamicList([3, 1, 2]);

sortList((a, b) => a - b); // Sorts list in ascending order
```

## `useInfiniteScroll`

`useInfiniteScroll` is a custom hook provided by the `ahooks` library that simplifies the implementation of infinite scrolling in React applications. Infinite scrolling is a pattern where more content is loaded as the user scrolls down the page, creating a seamless experience without the need for pagination buttons. This hook manages the complexities of loading additional data as needed, ensuring a smooth and efficient user experience.

### Key Features

1. **Data Loading Management**: Automatically handles data fetching as the user scrolls, providing a callback to load more data.
2. **Scroll Container Configuration**: Supports specifying different scroll containers, not just the window.
3. **Threshold Setting**: Allows setting a threshold to determine when to trigger data loading before the user reaches the bottom.
4. **Loading State Management**: Provides states to manage loading and error handling.
5. **Customizable Options**: Offers various customization options to tailor the behavior to specific use cases.

### Basic Usage

Here’s a simple example to demonstrate the use of `useInfiniteScroll`:

```jsx
import React, { useState } from 'react';
import { useInfiniteScroll } from 'ahooks';

const InfiniteScrollComponent = () => {
  const [data, setData] = useState([]);
  const [page, setPage] = useState(1);

  const fetchMoreData = async () => {
    const response = await fetch(`https://api.example.com/data?page=${page}`);
    const newData = await response.json();
    setData((prevData) => [...prevData, ...newData]);
    setPage(page + 1);
  };

  const { data: infiniteData, loading, noMore, error } = useInfiniteScroll(fetchMoreData, {
    threshold: 100,
  });

  return (
    <div>
      {data.map((item, index) => (
        <div key={index}>{item.name}</div>
      ))}
      {loading && <p>Loading...</p>}
      {noMore && <p>No more data</p>}
      {error && <p>Error loading data</p>}
    </div>
  );
};

export default InfiniteScrollComponent;
```

### API

The `useInfiniteScroll` hook provides several configuration options and returns useful states:

#### Configuration Options

- **target**: The target container to listen for scroll events. Default is `window`.
- **threshold**: Distance in pixels from the bottom of the container to trigger loading. Default is `100`.
- **isNoMore**: A function to determine if there is no more data to load.
- **loadingDelay**: Delay in milliseconds before setting the loading state to `true`. Default is `0`.

#### Return Values

- **data**: The accumulated data from the infinite scroll.
- **loading**: A boolean indicating if data is currently being loaded.
- **noMore**: A boolean indicating if there is no more data to load.
- **error**: An error object if there was an error during data loading.

### Advanced Usage

For more complex use cases, `useInfiniteScroll` can be customized extensively. Here’s an example with custom scroll container and no more data condition:

```jsx
import React, { useState, useRef } from 'react';
import { useInfiniteScroll } from 'ahooks';

const CustomInfiniteScrollComponent = () => {
  const [data, setData] = useState([]);
  const [page, setPage] = useState(1);
  const containerRef = useRef(null);

  const fetchMoreData = async () => {
    const response = await fetch(`https://api.example.com/data?page=${page}`);
    const newData = await response.json();
    setData((prevData) => [...prevData, ...newData]);
    setPage(page + 1);
  };

  const isNoMore = data.length >= 100;

  const { loading, noMore, error } = useInfiniteScroll(fetchMoreData, {
    target: containerRef,
    threshold: 50,
    isNoMore: () => isNoMore,
  });

  return (
    <div ref={containerRef} style={{ height: '400px', overflowY: 'scroll' }}>
      {data.map((item, index) => (
        <div key={index}>{item.name}</div>
      ))}
      {loading && <p>Loading...</p>}
      {noMore && <p>No more data</p>}
      {error && <p>Error loading data</p>}
    </div>
  );
};

export default CustomInfiniteScrollComponent;
```

## `useVirtualList`

The `useVirtualList` hook is designed to optimize the rendering performance of large lists by implementing a virtualized list. Virtualization helps in rendering only the visible items within the viewport, reducing the amount of DOM manipulation and improving performance.

### Key Features

1. **Performance Optimization**: By only rendering the items that are visible within the scrollable area, `useVirtualList` helps in significantly reducing the rendering overhead, leading to smoother performance, especially for large lists.
   
2. **Customization**: The hook provides several customization options, allowing developers to adjust the behavior of the virtual list according to their specific needs.

3. **Ease of Integration**: It integrates seamlessly with React components, making it easy to adopt and use within existing projects.

#### Installation

To use `useVirtualList`, you need to have `ahooks` installed in your project. You can install it via npm or yarn:

```sh
npm install ahooks
```
or
```sh
yarn add ahooks
```

### Basic Usage

Here’s a basic example of how to use `useVirtualList` in a React component:

```jsx
import React from 'react';
import { useVirtualList } from 'ahooks';

const VirtualListExample = () => {
  const itemCount = 10000; // Example item count
  const itemHeight = 50; // Height of each item in pixels

  const { list, containerProps, wrapperProps, scrollTo } = useVirtualList(
    Array.from({ length: itemCount }).map((_, index) => ({ id: index, name: `Item ${index}` })),
    {
      itemHeight,
      overscan: 5, // Number of extra items to render beyond the visible area
    }
  );

  return (
    <div {...containerProps} style={{ height: 500, overflow: 'auto' }}>
      <div {...wrapperProps}>
        {list.map((item) => (
          <div key={item.data.id} style={{ height: itemHeight }}>
            {item.data.name}
          </div>
        ))}
      </div>
    </div>
  );
};

export default VirtualListExample;
```

### Parameters and Options

The `useVirtualList` hook takes two main parameters: the source list and an options object.

1. **Source List**: An array of data items to be rendered.

2. **Options Object**: This object allows you to configure the behavior of the virtual list. Key options include:
   - `itemHeight`: The fixed height of each item in the list.
   - `overscan`: Number of extra items to render before and after the visible items for smoother scrolling.
   - `estimateSize`: A function to estimate the size of each item if they have variable heights.

### Return Values

The hook returns an object with the following properties:

- **list**: An array of items currently being rendered. Each item contains the data and its position in the list.
- **containerProps**: Props to be spread on the container element.
- **wrapperProps**: Props to be spread on the wrapper element that contains the rendered items.
- **scrollTo**: A function to programmatically scroll to a specific item.

### Advanced Usage

For lists with variable item heights, you can provide an `estimateSize` function:

```jsx
import React from 'react';
import { useVirtualList } from 'ahooks';

const VirtualListVariableHeightExample = () => {
  const itemCount = 10000;

  const { list, containerProps, wrapperProps, scrollTo } = useVirtualList(
    Array.from({ length: itemCount }).map((_, index) => ({ id: index, name: `Item ${index}`, height: 30 + (index % 5) * 10 })),
    {
      itemHeight: 50, // Provide a default height
      overscan: 5,
      estimateSize: (index) => 30 + (index % 5) * 10, // Function to estimate item height
    }
  );

  return (
    <div {...containerProps} style={{ height: 500, overflow: 'auto' }}>
      <div {...wrapperProps}>
        {list.map((item) => (
          <div key={item.data.id} style={{ height: item.data.height }}>
            {item.data.name}
          </div>
        ))}
      </div>
    </div>
  );
};

export default VirtualListVariableHeightExample;
```

In this example, the `estimateSize` function dynamically calculates the height of each item.

## `usePagination`

`usePagination` is a custom React hook provided by the `ahooks` library, which simplifies the implementation of pagination logic in React applications. It abstracts away common pagination-related tasks, making it easier to manage paginated data, handle page changes, and integrate with APIs or other data sources.

### Basic Usage
The `usePagination` hook provides a straightforward way to manage paginated data. Here's a basic example of how to use it:

```jsx
import React from 'react';
import { usePagination } from 'ahooks';

const fetchData = ({ current, pageSize }) => {
  // Replace with your data fetching logic
  return fetch(`/api/data?page=${current}&size=${pageSize}`)
    .then(response => response.json());
};

const PaginatedComponent = () => {
  const { data, loading, pagination } = usePagination(fetchData, {
    defaultPageSize: 10,
  });

  return (
    <div>
      {loading ? (
        <p>Loading...</p>
      ) : (
        <ul>
          {data?.list?.map(item => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      )}
      <div>
        <button onClick={() => pagination.changePage(1)} disabled={pagination.current === 1}>
          First
        </button>
        <button onClick={pagination.prevPage} disabled={!pagination.hasPrev}>
          Previous
        </button>
        <button onClick={pagination.nextPage} disabled={!pagination.hasNext}>
          Next
        </button>
        <button onClick={() => pagination.changePage(pagination.totalPages)} disabled={pagination.current === pagination.totalPages}>
          Last
        </button>
        <span>
          Page {pagination.current} of {pagination.totalPages}
        </span>
      </div>
    </div>
  );
};

export default PaginatedComponent;
```

### API Reference
The `usePagination` hook returns an object with several properties and methods. Here is a detailed breakdown:

- **Properties:**
  - `data`: The paginated data returned by the `service` function.
  - `loading`: A boolean indicating whether the data is currently being loaded.
  - `pagination`: An object containing pagination-related properties and methods.

- **Pagination Object Properties:**
  - `current`: The current page number.
  - `pageSize`: The number of items per page.
  - `total`: The total number of items.
  - `totalPages`: The total number of pages.
  - `hasPrev`: A boolean indicating if there is a previous page.
  - `hasNext`: A boolean indicating if there is a next page.

- **Pagination Object Methods:**
  - `changePage`: A function to change to a specific page.
  - `prevPage`: A function to go to the previous page.
  - `nextPage`: A function to go to the next page.
  - `changePageSize`: A function to change the number of items per page.

#### Configuration Options
The `usePagination` hook accepts two parameters:

1. **Service Function (`service`):**
   - A function that fetches the paginated data. It receives an object containing `current` and `pageSize` as arguments.

2. **Options (`options`):**
   - An optional configuration object. Common options include:
     - `defaultCurrent`: The default current page (default: 1).
     - `defaultPageSize`: The default number of items per page (default: 10).
     - `onChange`: A callback function that gets called when the page or page size changes.
     - `formatResult`: A function to format the result of the service function. It should return an object containing `list` and `total`.

### Example with Configuration Options
```jsx
const PaginatedComponent = () => {
  const { data, loading, pagination } = usePagination(fetchData, {
    defaultCurrent: 1,
    defaultPageSize: 10,
    onChange: (current, pageSize) => {
      console.log(`Page: ${current}, PageSize: ${pageSize}`);
    },
    formatResult: (response) => ({
      list: response.items,
      total: response.totalCount,
    }),
  });

  // ...rest of the component
};
```

## `useDebounce`

`useDebounce` is used to debounce values and functions, reducing the frequency at which they are invoked. This is particularly useful in scenarios where you want to limit the rate of execution of a function, such as handling user input in a search field or resizing a window.

`useDebounce` helps to delay the processing of a value or the execution of a function until a specified amount of time has passed since it was last invoked. This can improve performance by preventing unnecessary operations and reducing the load on the system.

### Key Features

1. **Value Debouncing**: Delays the update of a value until a specified delay period has passed.
2. **Function Debouncing**: Delays the execution of a function, ensuring it is not called more frequently than the specified delay.

### API Reference

`useDebounce` provides two main hooks: `useDebounce` for values and `useDebounceFn` for functions.

#### `useDebounce`

This hook is used to debounce a value.

```typescript
const debouncedValue = useDebounce<T>(value: T, options?: { wait?: number, leading?: boolean, trailing?: boolean, maxWait?: number });
```

- `value`: The value to debounce.
- `options`: An optional object to configure the debounce behavior.
  - `wait`: The delay in milliseconds (default is 1000ms).
  - `leading`: Whether to invoke on the leading edge (default is false).
  - `trailing`: Whether to invoke on the trailing edge (default is true).
  - `maxWait`: The maximum time `value` can be delayed before it's invoked (default is undefined).

#### `useDebounceFn`

This hook is used to debounce a function.

```typescript
const { run, cancel, flush } = useDebounceFn<T>(fn: T, options?: { wait?: number, leading?: boolean, trailing?: boolean, maxWait?: number });
```

- `fn`: The function to debounce.
- `options`: An optional object to configure the debounce behavior.
  - `wait`: The delay in milliseconds (default is 1000ms).
  - `leading`: Whether to invoke on the leading edge (default is false).
  - `trailing`: Whether to invoke on the trailing edge (default is true).
  - `maxWait`: The maximum time `fn` can be delayed before it's invoked (default is undefined).

### Usage Examples

#### Debouncing a Value

Here’s how to debounce a value, such as an input field’s value:

```javascript
import React, { useState } from 'react';
import { useDebounce } from 'ahooks';

function DebouncedInput() {
  const [value, setValue] = useState('');
  const debouncedValue = useDebounce(value, { wait: 500 });

  return (
    <div>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
      <p>Debounced Value: {debouncedValue}</p>
    </div>
  );
}
```

In this example, `debouncedValue` will only update 500ms after the user stops typing.

#### Debouncing a Function

Here’s how to debounce a function, such as a search function that fetches data from an API:

```javascript
import React, { useState } from 'react';
import { useDebounceFn } from 'ahooks';

function DebouncedSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const { run: debouncedSearch } = useDebounceFn((q) => {
    fetch(`https://api.example.com/search?q=${q}`)
      .then((res) => res.json())
      .then((data) => setResults(data));
  }, { wait: 500 });

  const handleSearch = (e) => {
    setQuery(e.target.value);
    debouncedSearch(e.target.value);
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={handleSearch}
      />
      <ul>
        {results.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

In this example, the `debouncedSearch` function will only be called 500ms after the user stops typing in the input field, reducing the number of API requests.

### Advanced Configuration

- **Leading Edge Invocation**: If you want the debounced function to be called at the start of the delay period, set `leading: true`.
- **Trailing Edge Invocation**: The function is called at the end of the delay period by default (`trailing: true`), but you can disable it if needed.
- **Max Wait Time**: To ensure the function is invoked after a maximum time, even if the user keeps triggering it, use `maxWait`.

## `useThrottle`

The `useThrottle` hook in `ahooks` is a powerful utility designed to limit the number of times a function can be called over a specified period. This can be extremely useful in scenarios where a function might be called excessively, such as during scroll or resize events. Throttling ensures that the function is executed at most once every specified time interval, thus improving performance and reducing the load on the browser.

### Key Concepts

- **Throttling**: It limits the execution of a function to once every specified interval, regardless of how many times the event occurs.
- **Debouncing**: In contrast, debouncing delays the execution of a function until a specified period has elapsed since the last time it was invoked.

### Syntax

```javascript
const throttledValue = useThrottle(value, options);
```

### Parameters

- `value`: The value to be throttled. This can be any value that changes over time, such as a state variable.
- `options`: An optional object to configure the throttling behavior. It can include:
  - `wait`: The time in milliseconds to throttle executions. Default is `1000ms`.
  - `leading`: Boolean to indicate if the function should be invoked on the leading edge of the timeout. Default is `true`.
  - `trailing`: Boolean to indicate if the function should be invoked on the trailing edge of the timeout. Default is `true`.

### Returns

- `throttledValue`: The throttled version of the provided value. It updates at most once every `wait` milliseconds.

### Example Usage

```javascript
import React, { useState } from 'react';
import { useThrottle } from 'ahooks';

const ThrottledComponent = () => {
  const [value, setValue] = useState('');
  const throttledValue = useThrottle(value, { wait: 500 });

  const handleChange = (e) => {
    setValue(e.target.value);
  };

  return (
    <div>
      <input type="text" value={value} onChange={handleChange} />
      <p>Throttled Value: {throttledValue}</p>
    </div>
  );
};

export default ThrottledComponent;
```

In this example, the `value` state updates immediately on input changes, but the `throttledValue` only updates at most once every 500 milliseconds. This can help in reducing the frequency of expensive operations like API calls or complex calculations.

### Practical Applications

- **Scroll Events**: Throttling can significantly improve performance by reducing the number of times a scroll event handler is called.
- **Resize Events**: Similarly, handling resize events with throttling can prevent excessive recalculations and re-renders.
- **API Calls**: When making API calls based on user input, throttling can prevent the server from being overwhelmed by too many requests in a short period.

### Considerations

- **Leading vs. Trailing Execution**: By default, `useThrottle` invokes the function on both the leading and trailing edge of the interval. Depending on your use case, you might want to disable one of these. For instance, setting `leading` to `false` will prevent the function from being called immediately, and setting `trailing` to `false` will prevent it from being called at the end of the interval.
- **State Synchronization**: When dealing with React state, ensure that the throttled value is used appropriately within your components to avoid stale state issues.

## `useMap`

`useMap` is a hook designed to manage a Map object in a React component. Maps are collections of key-value pairs where keys can be of any data type. `useMap` provides a set of utilities to interact with the Map, making it easier to handle complex state management scenarios.

### Key Features:

- **Initialization**: Initialize the Map with a default set of key-value pairs.
- **Basic Operations**: Add, delete, and retrieve values from the Map.
- **Clearing**: Clear all entries in the Map.
- **Size**: Get the current size of the Map.
- **Entries**: Retrieve all entries in the Map as an array.

### Example Usage:

```jsx
import React from 'react';
import { useMap } from 'ahooks';

const ExampleComponent = () => {
  const [map, { set, get, remove, reset, clear }] = useMap([
    ['key1', 'value1'],
    ['key2', 'value2'],
  ]);

  return (
    <div>
      <button onClick={() => set('key3', 'value3')}>Add key3</button>
      <button onClick={() => remove('key1')}>Remove key1</button>
      <button onClick={() => clear()}>Clear All</button>
      <div>Value of key2: {get('key2')}</div>
    </div>
  );
};
```

### API:

- `set(key, value)`: Adds or updates a key-value pair in the Map.
- `get(key)`: Retrieves the value associated with the specified key.
- `remove(key)`: Deletes the key-value pair with the specified key.
- `reset(newMap)`: Resets the Map to a new set of key-value pairs.
- `clear()`: Clears all entries in the Map.
- `map`: The current state of the Map.

## `useSet`

`useSet` is a hook designed to manage a Set object in a React component. Sets are collections of unique values, meaning that any value in a Set can occur only once. `useSet` provides utilities to interact with the Set, making it easier to handle collections of unique items.

### Key Features:

- **Initialization**: Initialize the Set with a default set of values.
- **Basic Operations**: Add and delete values from the Set.
- **Clearing**: Clear all values in the Set.
- **Size**: Get the current size of the Set.
- **Values**: Retrieve all values in the Set as an array.

### Example Usage:

```jsx
import React from 'react';
import { useSet } from 'ahooks';

const ExampleComponent = () => {
  const [set, { add, remove, reset, clear }] = useSet(['value1', 'value2']);

  return (
    <div>
      <button onClick={() => add('value3')}>Add value3</button>
      <button onClick={() => remove('value1')}>Remove value1</button>
      <button onClick={() => clear()}>Clear All</button>
      <div>Set size: {set.size}</div>
    </div>
  );
};
```

### API:

- `add(value)`: Adds a new value to the Set.
- `remove(value)`: Deletes the specified value from the Set.
- `reset(newSet)`: Resets the Set to a new set of values.
- `clear()`: Clears all values in the Set.
- `set`: The current state of the Set.

## `useCreation`

`useCreation` is a specialized hook from the `ahooks` library, designed to optimize the creation and memoization of complex objects and values in React. It provides an alternative to the standard React hooks like `useMemo` and `useCallback` with some added guarantees and optimizations.

### `useCreation` Overview

### Basic Usage

The `useCreation` hook is typically used when you need to create complex objects, functions, or computations that should not be recalculated on every render unless certain dependencies change. Here's a basic example:

```javascript
import { useCreation } from 'ahooks';

const MyComponent = () => {
  const complexObject = useCreation(() => {
    return { value: Math.random() };
  }, []);

  return <div>{complexObject.value}</div>;
};
```

In this example, `complexObject` will be created once and will not change unless the dependencies in the second argument array change.

### Comparison with Other Memo Series Hooks

#### `useMemo`

`useMemo` is a standard React hook used to memoize a value. It recalculates the value only when its dependencies change. 

**Example:**
```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

**Pros:**
- Part of React's core API, no need for additional libraries.
- Good for simple memoization of values.

**Cons:**
- Does not provide strong guarantees about the referential equality of the returned value.
- Can still trigger recalculations if not used carefully.

#### `useCallback`

`useCallback` is similar to `useMemo` but is specifically designed for memoizing functions.

**Example:**
```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

**Pros:**
- Reduces the need to create functions on every render.
- Helps with performance optimization when passing callbacks to child components.

**Cons:**
- Same as `useMemo`, lacks strong guarantees about referential equality.

### `useCreation` vs. `useMemo`/`useCallback`

**useCreation** provides stronger guarantees and optimizations compared to `useMemo` and `useCallback`:

1. **Stable References:**
   `useCreation` ensures that the created object or function will have a stable reference, which can be crucial for avoiding unnecessary re-renders in deeply nested components or complex dependency arrays.

2. **Predictable Behavior:**
   It guarantees that the value will only be recalculated when dependencies change, providing a more predictable and reliable memoization behavior.

3. **Performance:**
   By ensuring referential equality, `useCreation` can help avoid performance pitfalls associated with unnecessary re-renders caused by changing references.

### Practical Example and Comparison

Let's compare a practical scenario where `useMemo` might not be sufficient:

**Using `useMemo`:**

```javascript
const expensiveObject = useMemo(() => {
  return { value: computeExpensiveValue(a, b) };
}, [a, b]);

// In some cases, React might still re-create the object unnecessarily.
```

**Using `useCreation`:**

```javascript
const expensiveObject = useCreation(() => {
  return { value: computeExpensiveValue(a, b) };
}, [a, b]);

// This ensures that `expensiveObject` has a stable reference and will only be re-created if `a` or `b` changes.
```

### Conclusion

`useCreation` is a powerful hook from `ahooks` that offers more reliable memoization for complex objects and values compared to `useMemo` and `useCallback`. Its main advantage lies in providing stable references and predictable behavior, making it a valuable tool for optimizing performance in React applications. While `useMemo` and `useCallback` are suitable for many common use cases, `useCreation` shines in scenarios where stability and performance are critical.

In the given code, the `useLatest` hook from `ahooks` is used to maintain a reference to the latest value of the `count` state. This helps in ensuring that the latest value is always used in the `setInterval` callback. Let's break down the code and understand why `count2` is not updating properly:

## `useLatest`

The `useLatest` hook from `ahooks` provides a way to get the latest value of a variable within a callback or asynchronous function. It returns a mutable reference object whose `.current` property is always the latest value of the given variable.

### Code Explanation

Here's the code with explanations:

```javascript
import React, { useState, useEffect } from 'react';
import { useLatest } from 'ahooks';

export default () => {
  const [count, setCount] = useState(0);
  const [count2, setCount2] = useState(0);

  const latestCountRef = useLatest(count); // Create a ref that always holds the latest value of count

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(latestCountRef.current + 1); // Use the latest value of count to update it
    }, 1000);
    return () => clearInterval(interval); // Cleanup the interval on unmount
  }, [latestCountRef]);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount2(count2 + 1); // This will use the initial value of count2 to update it
    }, 1000);
    return () => clearInterval(interval); // Cleanup the interval on unmount
  }, [count2]);

  return (
    <>
      <p>count(useLatest): {count}</p>
      <p>count(default): {count2}</p>
    </>
  );
};
```

### Why `count2` is Not Updating

The `count2` state is not updating as expected because of how the closure works in JavaScript. In the `setInterval` callback for `count2`, the value of `count2` is captured when the effect is initially run, which is `0`. Since `count2` is a dependency of the effect, the `setInterval` callback keeps using this initial value and increments it by `1` every second, but the updated value is not captured in the closure of the interval callback.

### Solution

To ensure `count2` updates properly, you should use the functional form of the state updater function. This form ensures that the latest state value is always used to compute the next state:

```javascript
import React, { useState, useEffect } from 'react';
import { useLatest } from 'ahooks';

export default () => {
  const [count, setCount] = useState(0);
  const [count2, setCount2] = useState(0);

  const latestCountRef = useLatest(count);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(latestCountRef.current + 1);
    }, 1000);
    return () => clearInterval(interval);
  }, [latestCountRef]);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount2(prevCount2 => prevCount2 + 1); // Use the functional updater form
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  return (
    <>
      <p>count(useLatest): {count}</p>
      <p>count(default): {count2}</p>
    </>
  );
};
```

### Explanation of the Solution

- **Functional State Updater**: The `setCount2` function is called with a function that takes the previous state (`prevCount2`) and returns the next state (`prevCount2 + 1`). This ensures that the latest state value is always used, even within the interval callback.
- **Effect Dependencies**: The dependency array for the second `useEffect` is now empty (`[]`). This ensures that the effect runs only once on mount, and the interval callback always has the latest state due to the functional updater.

### Conclusion

Using the `useLatest` hook from `ahooks` ensures the latest value of a variable is always available in a callback. For state updates in `setInterval` or similar asynchronous functions, using the functional updater form ensures the latest state value is used, preventing issues caused by stale closures.