## Design Principles
The most important principle in design patterns is the **Open/Closed Principle**, which states that a system should be open for extension but closed for modification. This means you should be able to add new functionality without changing the existing code.

## Factory Pattern
The Factory pattern involves using a factory function to create instances, effectively hiding the `new` keyword to encapsulate the creation process. This pattern is useful for scenarios where the creation process is complex or when there needs to be some control over how instances are created. Examples include the jQuery `$` function and React's `createElement` function.

**Example**:
```typescript
class Foo {}

function factory() {
    return new Foo();
}

const f = factory();
```

## Singleton Pattern
The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This is particularly useful for cases where a single instance of a class should be used across the system, such as the store in Vuex and Redux or a globally unique dialog/modal. JavaScript makes implementing singletons straightforward because there's no need to worry about multithreading issues that might arise in languages like Java, where thread locking mechanisms might be necessary to prevent multiple instances from being created.

**Example**:
```typescript
class Singleton {
    private static instance: Singleton;
    private constructor() {}
    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
    fn1() {}
    fn2() {}
}

const s = Singleton.getInstance();
s.fn1();
```

## Proxy Pattern
The Proxy pattern involves using a proxy layer that clients interact with instead of accessing the object directly. This allows for various operations, like monitoring or intercepting get and set operations, to be performed transparently. 

JavaScript `Proxy` is a versatile feature that enables the creation of a proxy for another object. This proxy allows for the interception and customization of operations performed on the original object, including property access, assignment, and enumeration. This capability is especially valuable for tracking changes in objects or arrays in a dynamic manner, enabling actions like logging additions to a list or triggering updates in response to changes.

### The Basics of Proxy

A `Proxy` in JavaScript acts as a sophisticated wrapper for an original object, granting fine-grained control over interactions with that object. Operations on the proxy can be intercepted to implement custom behaviors for fundamental operations such as property reads or writes.

### Practical Example: Monitoring List Additions

To demonstrate the utility of a `Proxy`, consider a use case where it's necessary to monitor additions to a list (an array) and perform actions like logging these additions, validating the new items, or updating the UI. A `Proxy` facilitates these tasks by allowing for custom handlers for get and set operations.

**Example Implementation**

The following example showcases the use of a `Proxy` to observe and react to new items being added to a list:

```javascript
// Handler object with traps for get and set operations
let handler = {
  // Trap for property access
  get(target, property, receiver) {
    console.log(`Accessing property '${property}'`);
    return Reflect.get(...arguments); // Uses Reflect API for default operations
  },
  // Trap for property assignment
  set(target, property, value, receiver) {
    console.log(`Adding '${value}' to the list`);
    target[property] = value; // Updates the target list
    // Here, additional actions can be implemented, such as validation or UI updates
    return true; // Indicates that the operation was successful
  }
};

// The original list to be monitored
let originalList = [];

// Creating the proxy for the original list
let proxyList = new Proxy(originalList, handler);

// Performing operations on the proxy list
proxyList.push('Apple');  // Output: Adding 'Apple' to the list
proxyList.push('Banana'); // Output: Adding 'Banana' to the list
```

In this enhanced example, interactions with the `proxyList` trigger the appropriate handler within the `handler` object. Adding a new item to the list via the `push` method activates the `set` trap, which logs the operation and facilitates additional actions like validations or UI adjustments.

### Advantages of Using Proxies

- **Interception and Customization**: Proxies offer a powerful means to intercept and tailor the behavior of fundamental operations on objects, enabling the implementation of custom behaviors and checks.
- **Programmatic Validation**: They provide a mechanism for enforcing programmatic validation rules and constraints on object properties, enhancing data integrity and application robustness.
- **Change Detection**: Proxies are instrumental in detecting changes to objects and arrays, supporting reactive programming patterns by facilitating dynamic responses to data modifications.

## Observer Pattern
The Observer pattern is widely used in front-end development. It involves a subject and observers, where the observers are notified and updated whenever the subject undergoes a change. A common example is attaching click event listeners to a button, where each listener acts as an observer to the button's click event.

**Example**:
```typescript
btn.addEventListener('click', () => {
    console.log('click');
});
```

## Publish-Subscribe Pattern
Similar to the Observer pattern, the Publish-Subscribe pattern provides a more decoupled way for components to communicate. Components can publish events to a specific event channel and subscribe to this channel to receive notifications. It's important to unsubscribe from events, especially in component lifecycle hooks, to prevent memory leaks.

**Example**:
```typescript
event.on('event-key', () => {
    console.log('event 1');
});
event.on('event-key', () => {
    console.log('event 2');
});
event.emit('event-key');

// Remember to unsubscribe
function fn1() {}
event.on('event-key', fn1);
event.off('event-key', fn1);
```

## Decorator Pattern
The Decorator pattern allows for behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class. This pattern is similar to Aspect-Oriented Programming (AOP) and is supported in ES and TypeScript through decorator syntax. It's particularly useful for adding features or functionalities to existing classes without modifying them.

**Example**:
```typescript
@testable
class MyTestableClass {
    // ...
}

function testable(target) {
    target.isTestable = true;
}

console.log(MyTestableClass.isTestable);
```
In the example above, `@testable` is a decorator that adds new functionality to `MyTestableClass`.

## What's the distinction between the Observer pattern and the Publish-Subscribe pattern?

### Observer Pattern
In the Observer pattern, the subject (the object being observed) and the observers (the objects that want to be notified of changes in the subject) have direct knowledge of each other. This means there is a direct relationship where the subject holds references to the observers and directly notifies them of any changes. This pattern allows for a straightforward and direct communication line but can lead to higher coupling between the subject and its observers.

#### Characteristics:
- **Direct Communication**: Observers are directly registered with the subject.
- **Coupling**: There is a higher degree of coupling, as the subject and observers are directly aware of each other.
- **Use Case**: Suitable for simpler scenarios where the subject's state change is of interest to specific observers directly related to the subject.

### Publish-Subscribe Pattern
The Publish-Subscribe pattern, on the other hand, introduces a middle layer known as the "event channel" or "message broker," which decouples the publishers (the sources of events) from the subscribers (the receivers of events). Publishers publish events to the event channel without knowing who the subscribers will be. Similarly, subscribers listen for events through the event channel without knowing who the publishers are. This level of indirection adds flexibility and reduces coupling between components, making the system more scalable and easier to extend.

#### Characteristics:
- **Indirect Communication**: The communication between publishers and subscribers is mediated by an event channel, without direct knowledge of each other.
- **Coupling**: There is lower coupling due to the presence of the event channel as an intermediary.
- **Use Case**: Ideal for more complex scenarios where the event source and event consumers need to remain decoupled for scalability and maintainability reasons.

In summary, the key difference lies in the relationship and communication method between the parties involved: the Observer pattern facilitates direct communication between the subject and its observers, resulting in tighter coupling, whereas the Publish-Subscribe pattern uses an event channel to mediate communication, leading to looser coupling and greater flexibility.

