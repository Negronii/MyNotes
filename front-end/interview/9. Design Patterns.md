## Design Principles
The most important principle in design patterns is the **Open/Closed Principle**, which states that a system should be open for extension but closed for modification. This means you should be able to add new functionality without changing the existing code.

## Factory Pattern
The Factory pattern involves using a factory function to create instances, effectively hiding the `new` keyword to encapsulate the creation process. This pattern is useful for scenarios where the creation process is complex or when there needs to be some control over how instances are created. Examples include the jQuery `$` function and React's `createElement` function.

**Example**:
```typescript
class Foo {}

function factory() {
    return new Foo();
}

const f = factory();
```

## Singleton Pattern
The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This is particularly useful for cases where a single instance of a class should be used across the system, such as the store in Vuex and Redux or a globally unique dialog/modal. JavaScript makes implementing singletons straightforward because there's no need to worry about multithreading issues that might arise in languages like Java, where thread locking mechanisms might be necessary to prevent multiple instances from being created.

**Example**:
```typescript
class Singleton {
    private static instance: Singleton;
    private constructor() {}
    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
    fn1() {}
    fn2() {}
}

const s = Singleton.getInstance();
s.fn1();
```

## Proxy Pattern
The Proxy pattern in software design encapsulates an object with a proxy, which intercepts and controls interactions with that object. This pattern is particularly useful in JavaScript for operations like monitoring, logging, and performing custom actions on property access or assignment.

JavaScript `Proxy` is a powerful feature that allows for the creation of a proxy for another object. It enables the interception and customization of fundamental operations performed on the original object, including property access, assignment, and enumeration. This feature is invaluable for scenarios such as tracking changes, enforcing validations, and dynamically updating UI based on data changes.

### The Basics of Proxy
In JavaScript, a `Proxy` serves as a sophisticated handler for an original object, allowing fine-grained control over how interactions with that object are managed. This control extends to almost all operations performed on the object, enabling developers to define custom behaviors for property access, updates, and more.

### Practical Example: Monitoring List Additions
This example illustrates how a `Proxy` can be used to monitor and log additions to an array, potentially triggering other actions like validations or UI updates:

**Example Implementation**
```javascript
// Define handler with traps for get and set operations
let handler = {
  // Trap for property access
  get(target, property, receiver) {
    console.log(`Accessing property '${property}'`);
    return Reflect.get(...arguments);
  },
  // Trap for property assignment
  set(target, property, value, receiver) {
    console.log(`Adding '${value}' to the list`);
    target[property] = value; // Update the target list
    // Implement additional actions like validation or UI updates here
    return true; // Confirm the operation's success
  }
};

// Initialize the original list
let originalList = [];

// Create the proxy for the original list
let proxyList = new Proxy(originalList, handler);

// Use the proxy list to perform operations
proxyList.push('Apple');  // Output: Adding 'Apple' to the list
proxyList.push('Banana'); // Output: Adding 'Banana' to the list
```
This example demonstrates the `Proxy` pattern's utility in JavaScript, where interactions with `proxyList` trigger the defined handlers, allowing for enhanced control and responsiveness in applications.

### Advantages of Using Proxies
- **Interception and Customization**: Proxies enable precise control over how operations on objects are conducted, facilitating the implementation of additional behaviors and validations.
- **Programmatic Validation**: They offer a robust method for enforcing rules and constraints programmatically, which helps maintain data integrity and robustness in applications.
- **Change Detection**: Proxies are essential in reactive programming patterns where changes to objects or arrays need to trigger dynamic responses.

### JavaScript Quirk: Overcoming Paradoxical Conditions
The following TypeScript example demonstrates an interesting use of property definitions to satisfy seemingly paradoxical conditions:

```ts
// Using Object.defineProperty to manipulate property accesses dynamically
Object.defineProperty(window, 'a', {
  get: function() {
    this.value = this.value || 0;
    return ++this.value;
  }
});

if (a === 1 && a === 2 && a === 3) {
  console.log('Hello World!');
}
```
In this scenario, `Object.defineProperty` is employed similarly to a proxy, allowing dynamic manipulation of property access. It defines a getter for the property `a` that increments its value each time it's accessed, thereby making the condition `a === 1 && a === 2 && a === 3` true.

## Observer Pattern
The Observer pattern is widely used in front-end development. It involves a subject and observers, where the observers are notified and updated whenever the subject undergoes a change. A common example is attaching click event listeners to a button, where each listener acts as an observer to the button's click event.

**Example**:
```typescript
btn.addEventListener('click', () => {
    console.log('click');
});
```

## Publish-Subscribe Pattern
Similar to the Observer pattern, the Publish-Subscribe pattern provides a more decoupled way for components to communicate. Components can publish events to a specific event channel and subscribe to this channel to receive notifications. It's important to unsubscribe from events, especially in component lifecycle hooks, to prevent memory leaks.

**Example**:
```typescript
event.on('event-key', () => {
    console.log('event 1');
});
event.on('event-key', () => {
    console.log('event 2');
});
event.emit('event-key');

// Remember to unsubscribe
function fn1() {}
event.on('event-key', fn1);
event.off('event-key', fn1);
```

## Decorator Pattern
The Decorator pattern allows for behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class. This pattern is similar to Aspect-Oriented Programming (AOP) and is supported in ES and TypeScript through decorator syntax. It's particularly useful for adding features or functionalities to existing classes without modifying them.

**Example**:
```typescript
@testable
class MyTestableClass {
    // ...
}

function testable(target) {
    target.isTestable = true;
}

console.log(MyTestableClass.isTestable);
```
In the example above, `@testable` is a decorator that adds new functionality to `MyTestableClass`.

## What's the distinction between the Observer pattern and the Publish-Subscribe pattern?

### Observer Pattern
In the Observer pattern, the subject (the object being observed) and the observers (the objects that want to be notified of changes in the subject) have direct knowledge of each other. This means there is a direct relationship where the subject holds references to the observers and directly notifies them of any changes. This pattern allows for a straightforward and direct communication line but can lead to higher coupling between the subject and its observers.

#### Characteristics:
- **Direct Communication**: Observers are directly registered with the subject.
- **Coupling**: There is a higher degree of coupling, as the subject and observers are directly aware of each other.
- **Use Case**: Suitable for simpler scenarios where the subject's state change is of interest to specific observers directly related to the subject.

### Publish-Subscribe Pattern
The Publish-Subscribe pattern, on the other hand, introduces a middle layer known as the "event channel" or "message broker," which decouples the publishers (the sources of events) from the subscribers (the receivers of events). Publishers publish events to the event channel without knowing who the subscribers will be. Similarly, subscribers listen for events through the event channel without knowing who the publishers are. This level of indirection adds flexibility and reduces coupling between components, making the system more scalable and easier to extend.

#### Characteristics:
- **Indirect Communication**: The communication between publishers and subscribers is mediated by an event channel, without direct knowledge of each other.
- **Coupling**: There is lower coupling due to the presence of the event channel as an intermediary.
- **Use Case**: Ideal for more complex scenarios where the event source and event consumers need to remain decoupled for scalability and maintainability reasons.

In summary, the key difference lies in the relationship and communication method between the parties involved: the Observer pattern facilitates direct communication between the subject and its observers, resulting in tighter coupling, whereas the Publish-Subscribe pattern uses an event channel to mediate communication, leading to looser coupling and greater flexibility.

