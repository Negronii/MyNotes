# JavaScript's Strict Mode Features

JavaScript's Strict Mode is a feature that enforces a stricter parsing and error handling mechanism on your JavaScript code. Activating Strict Mode can be done by adding `'use strict';` at the beginning of a script or a function block. This mode intentionally has different semantics from the normal code, aimed at improving code reliability and performance.

## Features of Strict Mode

1. **Mandatory Variable Declarations**: In Strict Mode, every variable must be declared before use. If a script attempts to use an undeclared variable, JavaScript will throw a `ReferenceError`. This requirement helps to avoid the accidental creation of global variables caused by typographical errors.

2. **Disallows the `with` Statement**: The `with` statement is not allowed in Strict Mode because it creates ambiguity about the scope of variables. Its use can lead to significant performance hits and complicates the debugging process, as it modifies the scope chain, making it harder to predict which variables will be affected by a piece of code.

3. **Scoped `eval()` Function**: Any declarations within an `eval()` expression in Strict Mode do not affect the surrounding scope, making `eval()` safer by preventing it from introducing new variables or modifying existing ones in the parent scope.

4. **Secure `this` Keyword Behavior**: In functions that are not called as methods of an object, the value of `this` is `undefined` in Strict Mode. This contrasts with non-strict mode, where `this` defaults to the global object, reducing the risk of inadvertently modifying the global environment.

5. **Prohibits Duplicate Parameter Names**: Functions cannot have multiple parameters with the same name, which eliminates potential errors from duplicated identifiers and enhances code clarity.

6. **Immutable Non-Writable Properties**: In Strict Mode, attempts to assign values to non-writable properties result in a `TypeError`. This feature ensures the immutability of constants and read-only properties, thus preserving data integrity.

7. **Restrictions on Deleting Properties**: Trying to delete non-deletable properties (such as built-in objects or fixed properties) will throw a `TypeError`, protecting important parts of the language’s core.

8. **No Octal Numeric Literals**: Octal literals and octal escape sequences are not allowed in Strict Mode. This restriction avoids confusion between mistakenly leading zeroes in numbers and octal syntax, making the code more readable and less prone to errors. 
   - Octal literals are those starting with a leading zero, like `010` stands for 8 in decimal. Octal escape sequences are those starting with `\`, like `\141` stands for `'a'`. We can use `u0061` instead of `\141` to represent `'a'`, and `0o10` instead of `010` to represent `8`.

# JavaScript Variable Declarations: `var`, `let`, and `const`

## `var` Declaration
**Hoisting and Function Scope**

The `var` keyword declares a variable that is hoisted to the top of its functional or global scope, despite where it is defined. This hoisting means the variable is moved to the top of its containing scope during execution but is not initialized until its declaration is reached in the code.

```javascript
console.log(a); // Outputs: undefined
var a = 10;
console.log(a); // Outputs: 10
function foo() {
    console.log(a); // Outputs: undefined
    var a = 20;
    console.log(a); // Outputs: 20
}
```

**Key Characteristics:**
- Variables are hoisted and accessible within their scope, but only initialized where defined.
- Can be redeclared within the same scope without errors.

## `let` Declaration
**Block Scope and No Hoisting**

Unlike `var`, `let` is block-scoped and is not hoisted, which means the variable only exists within the block it is declared and cannot be accessed before its declaration.

```javascript
console.log(a); // Throws ReferenceError: Cannot access 'a' before initialization
let a = 10;
console.log(a); // Outputs: 10
function foo() {
    console.log(a); // Throws ReferenceError: Cannot access 'a' before initialization
    let a = 20;
    console.log(a); // Outputs: 20
    // let a = 30; // SyntaxError: Identifier 'a' has already been declared
}
console.log(a); // Outputs: 10
```

**Key Characteristics:**
- Block-scoped: accessible only within the block where declared. (note `var` is function-scoped, so `var` can be used outside `if` or `for` blocks, but `let` cannot)
- Cannot be accessed before declaration, preventing runtime errors due to uninitialized variables.
- Cannot be redeclared within the same block.

## `const` Declaration
**Block Scope and Immutable Binding**

`const` behaves like `let` in terms of block scope and no hoisting, but it requires that the variable be initialized at the time of declaration. Once set, the variable’s binding cannot be reassigned, although the content of mutable objects can still be altered.

```javascript
console.log(a); // Throws ReferenceError: Cannot access 'a' before initialization
// const a; // SyntaxError: Missing initializer in const declaration
const a = 10;
console.log(a); // Outputs: 10
// a = 20; // TypeError: Assignment to constant variable

const b = [];
b[0] = 10; // Allowed: modifying an object's content
// b = [10]; // SyntaxError: Assignment to constant variable
```

**Key Characteristics:**
- Block-scoped and requires initial value.
- The binding is immutable, meaning the variable identifier cannot be reassigned.
- Suitable for declaring constants where the value should not change through reassignment.

## Best Practices
ECMAScript 6 introduced `let` and `const` to address the issues associated with `var` and provide more robust variable declaration options. Here are some best practices for using these declarations effectively:
1. Do not use `var` unless necessary, as `let` and `const` offer better scoping and error prevention.

# Why 0.1 + 0.2 !== 0.3
This is a result of how computers handle binary floating-point arithmetic.

When you add these approximations, the tiny errors in their representation lead to results that are not exact, hence 0.1 + 0.2 results in something slightly different from 0.3. 

In practical terms, to compare floating-point numbers in such cases, a common approach is to check if they are close enough to each other, within a small tolerance, rather than expecting exact equality.

```javascript
const tolerance = 0.0001;
const sum = 0.1 + 0.2;
const target = 0.3;

if (Math.abs(sum - target) < tolerance) {
    console.log('Equal');
} else {
    console.log('Not Equal');
}
```
